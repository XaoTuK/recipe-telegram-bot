#!/usr/bin/env python3
import os
import logging
import re
import time
import requests
import json
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    filters, 
    ContextTypes, 
    ConversationHandler
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
BOT_TOKEN = os.environ.get('BOT_TOKEN')
YANDEX_API_KEY = os.environ.get('YANDEX_API_KEY')
FOLDER_ID = os.environ.get('FOLDER_ID')

# URL –¥–ª—è YandexGPT API
YANDEX_GPT_URL = "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞
(
    AWAITING_PRODUCTS,
    AWAITING_DISH_TYPE, 
    AWAITING_TIME,
    AWAITING_PREFERENCES,
    AWAITING_PORTIONS,
    AWAITING_CALORIES,
    AWAITING_VALIDATION_CONFIRMATION
) = range(7)

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –≤—ã–±–æ—Ä–∞
DISH_TYPE_KEYBOARD = [["üç≤ –°–∞–ª–∞—Ç", "üçú –°—É–ø"], ["üçõ –ì–æ—Ä—è—á–µ–µ", "üç∞ –î–µ—Å–µ—Ä—Ç"], ["üé≤ –ü—Ä–µ–¥–ª–æ–∂–∏ –≤–∞—Ä–∏–∞–Ω—Ç"]]
TIME_KEYBOARD = [["üî∏ 15 –º–∏–Ω", "üî∏ 30 –º–∏–Ω"], ["üî∏ 45 –º–∏–Ω", "üî∏ 60 –º–∏–Ω+"], ["‚è∞ –ù–µ –≤–∞–∂–Ω–æ"]]
PORTIONS_KEYBOARD = [["1-2", "3-4"], ["5-6", "7+"]]
CALORIES_KEYBOARD = [["‚úÖ –î–∞", "‚ùå –ù–µ—Ç"]]
VALIDATION_KEYBOARD = [["‚úÖ –î–∞, –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", "‚ùå –ù–µ—Ç, –∏–∑–º–µ–Ω–∏—Ç—å —Å–ø–∏—Å–æ–∫"]]

class ProductValidator:
    def __init__(self):
        self.products_url = os.environ.get('PRODUCTS_DATA_URL')
        self.products_data = None
        self.last_update = None
        
    def load_products_data(self) -> dict:
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –∏–∑ –≤–Ω–µ—à–Ω–µ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞"""
        if (self.products_data and self.last_update and 
            (time.time() - self.last_update) < 3600):
            return self.products_data
            
        try:
            if self.products_url:
                response = requests.get(self.products_url, timeout=10)
                self.products_data = response.json()
            else:
                with open('products_data.json', 'r', encoding='utf-8') as f:
                    self.products_data = json.load(f)
            
            self.last_update = time.time()
            return self.products_data
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤: {e}")
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –±–∞–∑–æ–≤—ã–π –Ω–∞–±–æ—Ä –Ω–∞ —Å–ª—É—á–∞–π –æ—à–∏–±–∫–∏
            return {
                "products": ["–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å", "–º–æ—Ä–∫–æ–≤—å", "–ª—É–∫", "–ø–æ–º–∏–¥–æ—Ä—ã", "–æ–≥—É—Ä—Ü—ã", "–∫—É—Ä–∏—Ü–∞", "–≥–æ–≤—è–¥–∏–Ω–∞", "—Å–≤–∏–Ω–∏–Ω–∞", "—Ä–∏—Å", "–≥—Ä–µ—á–∫–∞"],
                "corrections": {},
                "blocked_words": []
            }
    
    @staticmethod
    def clean_input(text: str) -> str:
        """–û—á–∏—â–∞–µ—Ç –≤—Ö–æ–¥–Ω–æ–π —Ç–µ–∫—Å—Ç"""
        text = text.lower()
        text = ' '.join(text.split())
        text = re.sub(r'[^\w\s,]', '', text)
        return text
    
    @staticmethod
    def parse_products(text: str) -> list:
        """–†–∞–∑–±–∏–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç—ã"""
        products = [p.strip() for p in text.split(',')]
        products = [p for p in products if p]
        return products
    
    def validate_products(self, user_input: str) -> dict:
        """–í–∞–ª–∏–¥–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç"""
        products_data = self.load_products_data()
        real_products = set(products_data.get("products", []))
        corrections = products_data.get("corrections", {})
        blocked_words = set(products_data.get("blocked_words", []))
        
        cleaned_input = self.clean_input(user_input)
        products_list = self.parse_products(cleaned_input)
        
        valid_products = []
        invalid_products = []
        corrected_products = []
        
        for product in products_list:
            if self.contains_blocked_words(product, blocked_words):
                invalid_products.append(product)
                continue
                
            corrected_product = self.correct_spelling(product, corrections)
            if corrected_product != product:
                corrected_products.append(f"{product} ‚Üí {corrected_product}")
                product = corrected_product
            
            if self.is_real_product(product, real_products):
                valid_products.append(product)
            else:
                invalid_products.append(product)
        
        return {
            "valid": valid_products,
            "invalid": invalid_products,
            "corrected": corrected_products,
            "original_input": user_input,
            "is_valid": len(valid_products) >= 1 and len(invalid_products) == 0
        }
    
    def contains_blocked_words(self, product: str, blocked_words: set) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –Ω–µ—Ü–µ–Ω–∑—É—Ä–Ω—ã—Ö —Å–ª–æ–≤"""
        product_lower = product.lower()
        return any(blocked_word in product_lower for blocked_word in blocked_words)
    
    def correct_spelling(self, product: str, corrections: dict) -> str:
        """–ò—Å–ø—Ä–∞–≤–ª—è–µ—Ç —á–∞—Å—Ç—ã–µ –æ–ø–µ—á–∞—Ç–∫–∏"""
        product_lower = product.lower()
        for wrong, correct in corrections.items():
            if wrong in product_lower:
                return correct
        return product
    
    def is_real_product(self, product: str, real_products: set) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –ø—Ä–æ–¥—É–∫—Ç –≤ –±–µ–ª–æ–º —Å–ø–∏—Å–∫–µ"""
        product_lower = product.lower()
        
        if product_lower in real_products:
            return True
        
        for real_product in real_products:
            if real_product in product_lower or product_lower in real_product:
                return True
        
        return False

# –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞
product_validator = ProductValidator()

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    welcome_text = """
üç≥ *–ü—Ä–∏–≤–µ—Ç! –Ø RecipeChefAI - —Ç–≤–æ–π —É–º–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –≤ –≥–æ—Ç–æ–≤–∫–µ!*

–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —É —Ç–µ–±—è –µ—Å—Ç—å, –∏ —è:
‚Ä¢ –ü—Ä–∏–¥—É–º–∞—é –≤–∫—É—Å–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç üéØ
‚Ä¢ –£—á—Ç—É —Ç–≤–æ–∏ –ø–æ–∂–µ–ª–∞–Ω–∏—è ‚≠ê  
‚Ä¢ –ü–æ–¥—Å–∫–∞–∂—É –ø–æ –≤—Ä–µ–º–µ–Ω–∏ ‚è±Ô∏è
‚Ä¢ –†–∞—Å—Å—á–∏—Ç–∞—é –ö–ë–ñ–£ (–ø–æ –∂–µ–ª–∞–Ω–∏—é) üìä

*–ù–∞–ø—Ä–∏–º–µ—Ä:* `–∫—É—Ä–∏—Ü–∞, —Ä–∏—Å, –ª—É–∫, –º–æ—Ä–∫–æ–≤—å, –ø–æ–º–∏–¥–æ—Ä—ã`

*–ì–æ—Ç–æ–≤ –≥–æ—Ç–æ–≤–∏—Ç—å? –û—Ç–ø—Ä–∞–≤–ª—è–π –ø—Ä–æ–¥—É–∫—Ç—ã!* üöÄ
    """
    await update.message.reply_text(welcome_text, parse_mode='Markdown')
    
    context.user_data.clear()
    return AWAITING_PRODUCTS

async def handle_products(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–æ–≤"""
    user_message = update.message.text
    
    validation_result = product_validator.validate_products(user_message)
    context.user_data['validation_result'] = validation_result
    
    if not validation_result["is_valid"]:
        return await ask_validation_confirmation(update, validation_result)
    
    context.user_data['products'] = ', '.join(validation_result["valid"])
    
    await update.message.reply_text(
        "üçΩÔ∏è *–ß—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–≥–æ—Ç–æ–≤–∏—Ç—å?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(DISH_TYPE_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_DISH_TYPE

async def ask_validation_confirmation(update: Update, validation_result: dict):
    """–°–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø—Ä–∏ –ø—Ä–æ–±–ª–µ–º–∞—Ö —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π"""
    
    message_lines = ["ü§î *–Ø –Ω–∞—à–µ–ª –ø—Ä–æ–±–ª–µ–º—ã –≤ –≤–∞—à–µ–º —Å–ø–∏—Å–∫–µ:*"]
    
    if validation_result["valid"]:
        message_lines.append("\n‚úÖ *–ü—Ä–∏–Ω—è–ª:*")
        for product in validation_result["valid"]:
            message_lines.append(f"‚Ä¢ {product}")
    
    if validation_result["corrected"]:
        message_lines.append("\nüîÑ *–ò—Å–ø—Ä–∞–≤–∏–ª –æ–ø–µ—á–∞—Ç–∫–∏:*")
        for correction in validation_result["corrected"]:
            message_lines.append(f"‚Ä¢ {correction}")
    
    if validation_result["invalid"]:
        message_lines.append("\n‚ùå *–ù–µ –ø–æ–Ω—è–ª:*")
        for product in validation_result["invalid"]:
            message_lines.append(f"‚Ä¢ {product}")
    
    message_lines.append("\n*–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–µ—Ü–µ–ø—Ç –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤?*")
    
    await update.message.reply_text(
        "\n".join(message_lines),
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(VALIDATION_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_VALIDATION_CONFIRMATION

async def handle_validation_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏"""
    user_choice = update.message.text
    validation_result = context.user_data.get('validation_result', {})
    
    if user_choice == "‚úÖ –î–∞, –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å" and validation_result.get("valid"):
        context.user_data['products'] = ', '.join(validation_result["valid"])
        
        await update.message.reply_text(
            "üçΩÔ∏è *–ß—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–≥–æ—Ç–æ–≤–∏—Ç—å?*",
            parse_mode='Markdown',
            reply_markup=ReplyKeyboardMarkup(DISH_TYPE_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
        )
        
        return AWAITING_DISH_TYPE
    else:
        await update.message.reply_text(
            "üîÑ *–•–æ—Ä–æ—à–æ! –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤.*\n\n"
            "*–°–æ–≤–µ—Ç:* –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–µ–∞–ª—å–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ø—Ä–æ–¥—É–∫—Ç–æ–≤",
            parse_mode='Markdown',
            reply_markup=ReplyKeyboardRemove()
        )
        
        return AWAITING_PRODUCTS

async def handle_dish_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ —Ç–∏–ø–∞ –±–ª—é–¥–∞"""
    dish_type = update.message.text
    context.user_data['dish_type'] = dish_type
    
    await update.message.reply_text(
        "‚è±Ô∏è *–°–∫–æ–ª—å–∫–æ –º–∏–Ω—É—Ç —É –≤–∞—Å –µ—Å—Ç—å –Ω–∞ –≥–æ—Ç–æ–≤–∫—É?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(TIME_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_TIME

async def handle_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –≤—Ä–µ–º–µ–Ω–∏"""
    cooking_time = update.message.text
    context.user_data['cooking_time'] = cooking_time
    
    await update.message.reply_text(
        "üå± *–ï—Å—Ç—å –¥–∏–µ—Ç–∏—á–µ—Å–∫–∏–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –∏–ª–∏ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏—è?*\n\n"
        "*–ù–∞–ø—Ä–∏–º–µ—Ä:* –≤–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å–∫–æ–µ, –æ—Å—Ç—Ä–æ–µ, –±–µ–∑ –º–æ–ª–æ—á–Ω–æ–≥–æ, –¥–∏–µ—Ç–∏—á–µ—Å–∫–æ–µ\n"
        "*–ò–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–ø–∏—à–∏—Ç–µ:* –Ω–µ—Ç",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardRemove()
    )
    
    return AWAITING_PREFERENCES

async def handle_preferences(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–µ–¥–ø–æ—á—Ç–µ–Ω–∏–π"""
    preferences = update.message.text
    context.user_data['preferences'] = preferences
    
    await update.message.reply_text(
        "üë®‚Äçüë©‚Äçüëß‚Äçüë¶ *–ù–∞ —Å–∫–æ–ª—å–∫–æ —á–µ–ª–æ–≤–µ–∫ –≥–æ—Ç–æ–≤–∏–º?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(PORTIONS_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_PORTIONS

async def handle_portions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –ø–æ—Ä—Ü–∏–π"""
    portions = update.message.text
    context.user_data['portions'] = portions
    
    await update.message.reply_text(
        "üìä *–†–∞—Å—Å—á–∏—Ç–∞—Ç—å –ö–ë–ñ–£ (–∫–∞–ª–æ—Ä–∏–∏, –±–µ–ª–∫–∏, –∂–∏—Ä—ã, —É–≥–ª–µ–≤–æ–¥—ã) –¥–ª—è —Ä–µ—Ü–µ–ø—Ç–∞?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(CALORIES_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_CALORIES

async def handle_calories(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ —Ä–∞—Å—á–µ—Ç–∞ –∫–∞–ª–æ—Ä–∏–π –∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ—Ü–µ–ø—Ç–∞"""
    calories_choice = update.message.text
    context.user_data['need_calories'] = calories_choice == "‚úÖ –î–∞"
    
    await update.message.reply_text(
        "üéØ *–û—Ç–ª–∏—á–Ω–æ! –ì–µ–Ω–µ—Ä–∏—Ä—É—é —Ä–µ—Ü–µ–ø—Ç...*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardRemove()
    )
    
    try:
        await update.message.chat.send_action(action="typing")
        
        prompt = create_optimized_prompt(context.user_data)
        recipe_text = await get_recipe_from_yagpt(prompt)
        
        formatted_recipe = format_recipe_response(recipe_text, context.user_data.get('need_calories', False))
        await update.message.reply_text(formatted_recipe, parse_mode='HTML')
        
    except Exception as e:
        error_message = handle_error(e)
        await update.message.reply_text(error_message)
    
    context.user_data.clear()
    return ConversationHandler.END

def create_optimized_prompt(user_data: dict) -> str:
    """–°–æ–∑–¥–∞–µ—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ–º—Ç –¥–ª—è YandexGPT"""
    
    products = user_data.get('products', '')
    dish_type = user_data.get('dish_type', '')
    cooking_time = user_data.get('cooking_time', '')
    preferences = user_data.get('preferences', '')
    portions = user_data.get('portions', '')
    need_calories = user_data.get('need_calories', False)
    
    calories_section = ""
    if need_calories:
        calories_section = "6. üìä –ö–ë–ñ–£ (–∫–∞–ª–æ—Ä–∏–∏, –±–µ–ª–∫–∏, –∂–∏—Ä—ã, —É–≥–ª–µ–≤–æ–¥—ã –Ω–∞ –ø–æ—Ä—Ü–∏—é)"
    
    prompt = f"""
–¢—ã ‚Äî –æ–ø—ã—Ç–Ω—ã–π —à–µ—Ñ-–ø–æ–≤–∞—Ä –∏ –¥–∏–µ—Ç–æ–ª–æ–≥. –°–æ–∑–¥–∞–π –∫—É–ª–∏–Ω–∞—Ä–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç –∏—Å–ø–æ–ª—å–∑—É—è —ç—Ç–∏ –ø—Ä–æ–¥—É–∫—Ç—ã: {products}

–î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–∂–µ–ª–∞–Ω–∏—è:
- –¢–∏–ø –±–ª—é–¥–∞: {dish_type}
- –í—Ä–µ–º—è –≥–æ—Ç–æ–≤–∫–∏: {cooking_time}
- –ü–æ—Ä—Ü–∏–∏: {portions}
- –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏: {preferences}

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä–µ—Ü–µ–ø—Ç–∞:
1. üçΩÔ∏è –ù–∞–∑–≤–∞–Ω–∏–µ –±–ª—é–¥–∞ (–µ–º–æ–¥–∑–∏)
2. üìã –ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã (—Ç–æ—á–Ω—ã–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —á–∏—Å–ª–∞ –ø–æ—Ä—Ü–∏–π)
3. üë®‚Äçüç≥ –ü—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏–µ (—á–µ—Ç–∫–∏–µ –ø—Ä–æ–Ω—É–º–µ—Ä–æ–≤–∞–Ω–Ω—ã–µ —à–∞–≥–∏, –º–∞–∫—Å–∏–º—É–º 5 —à–∞–≥–æ–≤)
4. ‚è±Ô∏è –û–±—â–µ–µ –≤—Ä–µ–º—è –≥–æ—Ç–æ–≤–∫–∏
5. üí° –ü–æ–ª–µ–∑–Ω—ã–π —Å–æ–≤–µ—Ç –æ—Ç —à–µ—Ñ–∞
{calories_section}

–¢—Ä–µ–±–æ–≤–∞–Ω–∏—è:
- –†–µ—Ü–µ–ø—Ç –î–û–õ–ñ–ï–ù –±—ã—Ç—å —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–º –∏ –≤—ã–ø–æ–ª–Ω–∏–º—ã–º —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ –ø—Ä–æ–¥—É–∫—Ç–∞–º–∏
- –£—á–∏—Ç—ã–≤–∞–π –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –µ—Å–ª–∏ –æ–Ω–∏ —É–∫–∞–∑–∞–Ω—ã
- –û–±—ä–µ–º: 250-400 —Å–ª–æ–≤
- –Ø–∑—ã–∫: —Ç–æ—Ç –∂–µ —á—Ç–æ –∏ –∑–∞–ø—Ä–æ—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
- –¢–æ–ª—å–∫–æ –∫—É–ª–∏–Ω–∞—Ä–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç, –±–µ–∑ –ª–∏—à–Ω–∏—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤
"""
    return prompt

def format_recipe_response(recipe_text: str, need_calories: bool) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ—Ç–≤–µ—Ç —Ä–µ—Ü–µ–ø—Ç–∞ –≤ –∫—Ä–∞—Å–∏–≤—ã–π HTML"""
    
    lines = recipe_text.split('\n')
    formatted_lines = []
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        if any(marker in line for marker in ['üçΩÔ∏è', '–ù–∞–∑–≤–∞–Ω–∏–µ', 'ü•ò']):
            formatted_lines.append(f"<b>{line}</b>\n")
        elif any(marker in line for marker in ['üìã', '–ò–Ω–≥—Ä–µ–¥–∏–µ–Ω—Ç—ã', 'ü•ï']):
            formatted_lines.append(f"<b>{line}</b>")
        elif any(marker in line for marker in ['üë®‚Äçüç≥', '–ü—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏–µ', 'üç≥']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif any(marker in line for marker in ['‚è±Ô∏è', '–í—Ä–µ–º—è', 'üïí']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif any(marker in line for marker in ['üí°', '–°–æ–≤–µ—Ç', 'üåü']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif any(marker in line for marker in ['üìä', '–ö–ë–ñ–£', '–ö–∞–ª–æ—Ä–∏–∏']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif line.startswith(('‚Ä¢', '-', '1.', '2.', '3.', '4.', '5.')):
            formatted_lines.append(f"‚Ä¢ {line.lstrip('‚Ä¢- 12345.')}")
        else:
            formatted_lines.append(line)
    
    formatted_text = '\n'.join(formatted_lines)
    
    if need_calories:
        formatted_text += "\n\nüìä <i>–ö–ë–ñ–£ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–æ –ø—Ä–∏–±–ª–∏–∑–∏—Ç–µ–ª—å–Ω–æ</i>"
    
    formatted_text += "\n\n#—Ä–µ—Ü–µ–ø—Ç #–≤–∫—É—Å–Ω–æ #–≥–æ—Ç–æ–≤–∏–º–¥–æ–º–∞"
    
    return formatted_text

async def get_recipe_from_yagpt(prompt: str) -> str:
    """–§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å YandexGPT API"""
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Api-Key {YANDEX_API_KEY}",
        "x-folder-id": FOLDER_ID
    }
    
    data = {
        "modelUri": f"gpt://{FOLDER_ID}/yandexgpt-lite",
        "completionOptions": {
            "stream": False,
            "temperature": 0.7,
            "maxTokens": 2000
        },
        "messages": [
            {
                "role": "user",
                "text": prompt
            }
        ]
    }
    
    response = requests.post(YANDEX_GPT_URL, headers=headers, json=data, timeout=30)
    
    if response.status_code != 200:
        error_text = f"HTTP {response.status_code}: {response.text}"
        raise Exception(error_text)
    
    result = response.json()
    
    if ('result' not in result or 
        'alternatives' not in result['result'] or 
        not result['result']['alternatives']):
        raise Exception("–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –æ—Ç–≤–µ—Ç–∞ –æ—Ç YandexGPT")
    
    return result['result']['alternatives'][0]['message']['text']

def handle_error(error: Exception) -> str:
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ —Å –ø–æ–Ω—è—Ç–Ω—ã–º–∏ —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏"""
    error_message = str(error)
    logger.error(f"–û—à–∏–±–∫–∞: {error_message}")
    
    if "401" in error_message:
        return "üîê –û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ YandexGPT"
    elif "403" in error_message:
        return "üö´ –î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω"
    elif "429" in error_message:
        return "‚è≥ –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç –∑–∞–ø—Ä–æ—Å–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ"
    elif "500" in error_message:
        return "‚ö° –û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ YandexGPT"
    else:
        return "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ—Ü–µ–ø—Ç–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑."

async def handle_direct_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–æ–±—â–µ–Ω–∏–π –≤–Ω–µ –¥–∏–∞–ª–æ–≥–∞ - –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –Ω–∞—á–∞—Ç—å —Å /start"""
    await update.message.reply_text(
        "üç≥ –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å —Ä–µ—Ü–µ–ø—Ç, –Ω–∞—á–Ω–∏—Ç–µ —Å –∫–æ–º–∞–Ω–¥—ã /start\n\n"
        "–Ø –ø–æ–º–æ–≥—É –ø—Ä–∏–≥–æ—Ç–æ–≤–∏—Ç—å –≤–∫—É—Å–Ω–æ–µ –±–ª—é–¥–æ –∏–∑ –≤–∞—à–∏—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤!",
        reply_markup=ReplyKeyboardRemove()
    )

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û—Ç–º–µ–Ω–∞ –¥–∏–∞–ª–æ–≥–∞"""
    context.user_data.clear()
    await update.message.reply_text(
        "–î–∏–∞–ª–æ–≥ –æ—Ç–º–µ–Ω–µ–Ω. –ù–∞—á–Ω–∏—Ç–µ –∑–∞–Ω–æ–≤–æ —Å /start",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
    try:
        if not all([BOT_TOKEN, YANDEX_API_KEY, FOLDER_ID]):
            logger.error("–ù–µ –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã!")
            return
        
        application = Application.builder().token(BOT_TOKEN).build()
        
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler("start", start)],
            states={
                AWAITING_PRODUCTS: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_products)
                ],
                AWAITING_VALIDATION_CONFIRMATION: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_validation_confirmation)
                ],
                AWAITING_DISH_TYPE: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_dish_type)
                ],
                AWAITING_TIME: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_time)
                ],
                AWAITING_PREFERENCES: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_preferences)
                ],
                AWAITING_PORTIONS: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_portions)
                ],
                AWAITING_CALORIES: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_calories)
                ],
            },
            fallbacks=[CommandHandler("cancel", cancel)],
            allow_reentry=True
        )
        
        application.add_handler(conv_handler)
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_direct_message))
        
        logger.info("–ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
        application.run_polling(
            drop_pending_updates=True,
            allowed_updates=Update.ALL_TYPES
        )
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {e}")

if __name__ == "__main__":
    main()
