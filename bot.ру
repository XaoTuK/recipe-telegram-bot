#!/usr/bin/env python3
import os
import logging
import re
import time
import requests
import json
from functools import wraps
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    filters, 
    ContextTypes, 
    ConversationHandler
)

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
BOT_TOKEN = os.environ.get('BOT_TOKEN')
YANDEX_API_KEY = os.environ.get('YANDEX_API_KEY')
FOLDER_ID = os.environ.get('FOLDER_ID')

# URL –¥–ª—è YandexGPT API
YANDEX_GPT_URL = "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"

# –°–æ—Å—Ç–æ—è–Ω–∏—è –¥–∏–∞–ª–æ–≥–∞
(
    AWAITING_PRODUCTS,
    AWAITING_DISH_TYPE, 
    AWAITING_TIME,
    AWAITING_PREFERENCES,
    AWAITING_PORTIONS,
    AWAITING_CALORIES,
    AWAITING_VALIDATION_CONFIRMATION
) = range(7)

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –≤—ã–±–æ—Ä–∞
DISH_TYPE_KEYBOARD = [["üç≤ –°–∞–ª–∞—Ç", "üçú –°—É–ø"], ["üçõ –ì–æ—Ä—è—á–µ–µ", "üç∞ –î–µ—Å–µ—Ä—Ç"], ["üé≤ –ü—Ä–µ–¥–ª–æ–∂–∏ –≤–∞—Ä–∏–∞–Ω—Ç"]]
TIME_KEYBOARD = [["üî∏ 15 –º–∏–Ω", "üî∏ 30 –º–∏–Ω"], ["üî∏ 45 –º–∏–Ω", "üî∏ 60 –º–∏–Ω+"], ["‚è∞ –ù–µ –≤–∞–∂–Ω–æ"]]
PORTIONS_KEYBOARD = [["1-2", "3-4"], ["5-6", "7+"]]
CALORIES_KEYBOARD = [["‚úÖ –î–∞", "‚ùå –ù–µ—Ç"]]
VALIDATION_KEYBOARD = [["‚úÖ –î–∞, –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å", "‚ùå –ù–µ—Ç, –∏–∑–º–µ–Ω–∏—Ç—å —Å–ø–∏—Å–æ–∫"]]

def handle_telegram_errors(func):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ –≤ —Ö–µ–Ω–¥–ª–µ—Ä–∞—Ö"""
    @wraps(func)
    async def wrapper(update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs):
        try:
            return await func(update, context, *args, **kwargs)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –≤ {func.__name__}: {e}")
            error_text = "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –î–∞–≤–∞–π—Ç–µ –Ω–∞—á–Ω–µ–º –∑–∞–Ω–æ–≤–æ —Å /start"
            if update.message:
                await update.message.reply_text(error_text, reply_markup=ReplyKeyboardRemove())
            return ConversationHandler.END
    return wrapper

class ProductValidator:
    def __init__(self):
        self.products_url = os.environ.get('PRODUCTS_DATA_URL')
        self.products_data = None
        self.last_update = None
        
    def load_products_data(self) -> dict:
        """–ó–∞–≥—Ä—É–∂–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –∏–∑ –≤–Ω–µ—à–Ω–µ–≥–æ –∏—Å—Ç–æ—á–Ω–∏–∫–∞"""
        if (self.products_data and self.last_update and 
            (time.time() - self.last_update) < 3600):
            return self.products_data
            
        try:
            if self.products_url:
                response = requests.get(self.products_url, timeout=10)
                self.products_data = response.json()
            else:
                with open('products_data.json', 'r', encoding='utf-8') as f:
                    self.products_data = json.load(f)
            
            self.last_update = time.time()
            return self.products_data
            
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤: {e}")
            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –±–∞–∑–æ–≤—ã–π –Ω–∞–±–æ—Ä –Ω–∞ —Å–ª—É—á–∞–π –æ—à–∏–±–∫–∏
            return {
                "products": [
                    "–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å", "–º–æ—Ä–∫–æ–≤—å", "–ª—É–∫", "–ø–æ–º–∏–¥–æ—Ä—ã", "–æ–≥—É—Ä—Ü—ã", "–∫–∞–ø—É—Å—Ç–∞", 
                    "–∫—É—Ä–∏—Ü–∞", "–≥–æ–≤—è–¥–∏–Ω–∞", "—Å–≤–∏–Ω–∏–Ω–∞", "–∫–æ–ª–±–∞—Å–∞", "—Å–æ—Å–∏—Å–∫–∏", "—è–π—Ü–∞",
                    "—Ä–∏—Å", "–≥—Ä–µ—á–∫–∞", "–º–∞–∫–∞—Ä–æ–Ω—ã", "–º–æ–ª–æ–∫–æ", "—Å—ã—Ä", "—Å–º–µ—Ç–∞–Ω–∞", "—Ö–ª–µ–±",
                    "–º–∞–π–æ–Ω–µ–∑", "–∫–µ—Ç—á—É–ø", "–≥–æ—Ä—á–∏—Ü–∞", "—Å–æ–ª—å", "–ø–µ—Ä–µ—Ü", "—Å–∞—Ö–∞—Ä", "–º–∞—Å–ª–æ",
                    "—Å–ª–∏–≤–æ—á–Ω—ã–π —Å—ã—Ä", "–∫–æ–ø—á–µ–Ω–∞—è –∫–æ–ª–±–∞—Å–∞", "–≤–∞—Ä–µ–Ω–∞—è –∫–æ–ª–±–∞—Å–∞", "—Å–∞–ª—è–º–∏"
                ],
                "corrections": {
                    "–º–∞–Ω–¥–∞–≤–æ—à–∫–∏": "–º–∞–Ω–¥–∞—Ä–∏–Ω—ã",
                    "–∫–∞—Ä—Ç–æ—Ñ–µ–ª–∏–Ω": "–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å", 
                    "–∫–∞—Ä—Ç–æ—à–∫–∞": "–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å",
                    "–ø–æ–º–∏–¥–æ—Ä": "–ø–æ–º–∏–¥–æ—Ä—ã",
                    "–æ–≥—É—Ä—á–∏–∫": "–æ–≥—É—Ä—Ü—ã",
                    "–ø–µ—Ä–µ—Ü": "–ø–µ—Ä–µ—Ü –±–æ–ª–≥–∞—Ä—Å–∫–∏–π",
                    "–∫—É—Ä–∏–Ω": "–∫—É—Ä–∏—Ü–∞",
                    "–≥–æ–≤—è–¥–∏–Ω": "–≥–æ–≤—è–¥–∏–Ω–∞", 
                    "—Å–≤–∏–Ω–∏–Ω": "—Å–≤–∏–Ω–∏–Ω–∞",
                    "–º–∞–∫–∞—Ä–æ–Ω": "–º–∞–∫–∞—Ä–æ–Ω—ã",
                    "–≤–µ—Ä–º–∏—à–µ–ª—å": "–º–∞–∫–∞—Ä–æ–Ω—ã",
                    "—Å–ø–∞–≥–µ—Ç—Ç–∏": "–º–∞–∫–∞—Ä–æ–Ω—ã",
                    "—Å–æ—Å–∏—Å–∫–∞": "—Å–æ—Å–∏—Å–∫–∏",
                    "–∫–æ–ª–±–∞—Å–∫–∞": "–∫–æ–ª–±–∞—Å–∞",
                    "–º–∞–π–æ–Ω–µ–∑": "–º–∞–π–æ–Ω–µ–∑",
                    "—Å—ã—Ä–æ–∫": "—Å—ã—Ä"
                },
                "blocked_words": [
                    "—Ö—É–π", "–ø–∏–∑–¥–∞", "–µ–±–∞–ª", "–±–ª—è–¥—å", "–±–ª—è", "–µ–±–∞—Ç—å", "–≥–æ–Ω–¥–æ–Ω", 
                    "–º—É–¥–∞–∫", "–∂–æ–ø–∞", "—Å—É—á–∫–∞", "–¥–æ–ª–±–∞–µ–±", "—Ö—É–µ—Å–æ—Å", "–ø–∏–∑–¥–µ—Ü", 
                    "–æ—Ö—É–µ–Ω–Ω–æ", "–æ—Ö—É–µ–Ω–Ω—ã–π", "–æ—Ö—É–µ—Ç—å", "–≤—ã–µ–±–æ–∫", "–µ–±–ª–∞–Ω"
                ]
            }
    
    @staticmethod
    def clean_input(text: str) -> str:
        """–û—á–∏—â–∞–µ—Ç –≤—Ö–æ–¥–Ω–æ–π —Ç–µ–∫—Å—Ç"""
        text = text.lower()
        text = ' '.join(text.split())
        text = re.sub(r'[^\w\s,]', '', text)
        return text
    
    @staticmethod
    def parse_products(text: str) -> list:
        """–†–∞–∑–±–∏–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç –Ω–∞ –æ—Ç–¥–µ–ª—å–Ω—ã–µ –ø—Ä–æ–¥—É–∫—Ç—ã"""
        products = [p.strip() for p in text.split(',')]
        products = [p for p in products if p]
        return products
    
    def validate_products(self, user_input: str) -> dict:
        """–í–∞–ª–∏–¥–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤ –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç"""
        products_data = self.load_products_data()
        real_products = set(products_data.get("products", []))
        corrections = products_data.get("corrections", {})
        blocked_words = set(products_data.get("blocked_words", []))
        
        cleaned_input = self.clean_input(user_input)
        products_list = self.parse_products(cleaned_input)
        
        valid_products = []
        invalid_products = []
        corrected_products = []
        
        for product in products_list:
            if self.contains_blocked_words(product, blocked_words):
                invalid_products.append(product)
                continue
                
            corrected_product = self.correct_spelling(product, corrections)
            if corrected_product != product:
                corrected_products.append(f"{product} ‚Üí {corrected_product}")
                product = corrected_product
            
            if self.is_real_product(product, real_products):
                valid_products.append(product)
            else:
                invalid_products.append(product)
        
        return {
            "valid": valid_products,
            "invalid": invalid_products,
            "corrected": corrected_products,
            "original_input": user_input,
            "is_valid": len(valid_products) >= 1 and len(invalid_products) == 0
        }
    
    def contains_blocked_words(self, product: str, blocked_words: set) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –Ω–µ—Ü–µ–Ω–∑—É—Ä–Ω—ã—Ö —Å–ª–æ–≤"""
        product_lower = product.lower()
        return any(blocked_word in product_lower for blocked_word in blocked_words)
    
    def correct_spelling(self, product: str, corrections: dict) -> str:
        """–ò—Å–ø—Ä–∞–≤–ª—è–µ—Ç —á–∞—Å—Ç—ã–µ –æ–ø–µ—á–∞—Ç–∫–∏"""
        product_lower = product.lower()
        for wrong, correct in corrections.items():
            if wrong in product_lower:
                return correct
        return product
    
    def is_real_product(self, product: str, real_products: set) -> bool:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –µ—Å—Ç—å –ª–∏ –ø—Ä–æ–¥—É–∫—Ç –≤ –±–µ–ª–æ–º —Å–ø–∏—Å–∫–µ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π"""
        product_lower = product.lower().strip()
        
        # –ü—Ä—è–º–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
        if product_lower in real_products:
            return True
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –±–µ–∑ –ø—Ä–æ–±–µ–ª–æ–≤ –∏ –¥–µ—Ñ–∏—Å–æ–≤
        product_clean = re.sub(r'[\s-]', '', product_lower)
        for real_product in real_products:
            real_clean = re.sub(r'[\s-]', '', real_product)
            if product_clean == real_clean:
                return True
        
        # –ß–∞—Å—Ç–∏—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ (–ø—Ä–æ–¥—É–∫—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ)
        for real_product in real_products:
            # –ï—Å–ª–∏ —Ä–µ–∞–ª—å–Ω—ã–π –ø—Ä–æ–¥—É–∫—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤ –≤–≤–µ–¥–µ–Ω–Ω–æ–º –ø—Ä–æ–¥—É–∫—Ç–µ
            if real_product in product_lower:
                return True
            # –ï—Å–ª–∏ –≤–≤–µ–¥–µ–Ω–Ω—ã–π –ø—Ä–æ–¥—É–∫—Ç —Å–æ–¥–µ—Ä–∂–∏—Ç—Å—è –≤ —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–æ–¥—É–∫—Ç–µ  
            if product_lower in real_product:
                return True
        
        # –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–ª—É—á–∞–∏ –¥–ª—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤
        special_cases = {
            "–º–∞–π–æ–Ω–µ–∑": ["–º–∞–π–æ–Ω–µ–∑", "–º–∞–π–æ–Ω"],
            "–∫–µ—Ç—á—É–ø": ["–∫–µ—Ç—á—É–ø", "–∫–µ—Ç—á—É–ø", "–∫–æ—Ç—á—É–ø"],
            "–∫–æ–ª–±–∞—Å–∞": ["–∫–æ–ª–±–∞—Å–∞", "–∫–æ–ª–±–∞—Å–∫–∞", "–∫–æ–ª–±–∞—Å"],
            "—Å—ã—Ä": ["—Å—ã—Ä", "—Å—ã—Ä–æ–∫"],
            "—Ö–ª–µ–±": ["—Ö–ª–µ–±", "—Ö–ª–µ–±—É—à–∫–∞"],
            "–ø–æ–º–∏–¥–æ—Ä—ã": ["–ø–æ–º–∏–¥–æ—Ä", "–ø–æ–º–∏–¥–æ—Ä—ã", "—Ç–æ–º–∞—Ç"],
            "–æ–≥—É—Ä—Ü—ã": ["–æ–≥—É—Ä–µ—Ü", "–æ–≥—É—Ä—Ü—ã", "–æ–≥—É—Ä—á–∏–∫"]
        }
        
        for base_product, variants in special_cases.items():
            if any(variant in product_lower for variant in variants) and base_product in real_products:
                return True
        
        return False

# –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –≤–∞–ª–∏–¥–∞—Ç–æ—Ä–∞
product_validator = ProductValidator()

@handle_telegram_errors
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
    welcome_text = """
üç≥ *–ü—Ä–∏–≤–µ—Ç! –Ø RecipeChefAI - —Ç–≤–æ–π —É–º–Ω—ã–π –ø–æ–º–æ—â–Ω–∏–∫ –≤ –≥–æ—Ç–æ–≤–∫–µ!*

–ü—Ä–æ—Å—Ç–æ –æ—Ç–ø—Ä–∞–≤—å –º–Ω–µ —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —É —Ç–µ–±—è –µ—Å—Ç—å, –∏ —è:
‚Ä¢ –ü—Ä–∏–¥—É–º–∞—é –≤–∫—É—Å–Ω—ã–π —Ä–µ—Ü–µ–ø—Ç üéØ
‚Ä¢ –£—á—Ç—É —Ç–≤–æ–∏ –ø–æ–∂–µ–ª–∞–Ω–∏—è ‚≠ê  
‚Ä¢ –ü–æ–¥—Å–∫–∞–∂—É –ø–æ –≤—Ä–µ–º–µ–Ω–∏ ‚è±Ô∏è
‚Ä¢ –†–∞—Å—Å—á–∏—Ç–∞—é –ö–ë–ñ–£ (–ø–æ –∂–µ–ª–∞–Ω–∏—é) üìä

*–ù–∞–ø—Ä–∏–º–µ—Ä:* `–∫—É—Ä–∏—Ü–∞, —Ä–∏—Å, –ª—É–∫, –º–æ—Ä–∫–æ–≤—å, –ø–æ–º–∏–¥–æ—Ä—ã, –∫–æ–ª–±–∞—Å–∞, —Å–æ—Å–∏—Å–∫–∏, –º–∞–π–æ–Ω–µ–∑`

*–ì–æ—Ç–æ–≤ –≥–æ—Ç–æ–≤–∏—Ç—å? –û—Ç–ø—Ä–∞–≤–ª—è–π –ø—Ä–æ–¥—É–∫—Ç—ã!* üöÄ
    """
    await update.message.reply_text(welcome_text, parse_mode='Markdown')
    
    context.user_data.clear()
    return AWAITING_PRODUCTS

@handle_telegram_errors
async def handle_products(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –ø—Ä–æ–¥—É–∫—Ç–æ–≤"""
    user_message = update.message.text
    
    validation_result = product_validator.validate_products(user_message)
    context.user_data['validation_result'] = validation_result
    
    if not validation_result["is_valid"]:
        return await ask_validation_confirmation(update, validation_result)
    
    context.user_data['products'] = ', '.join(validation_result["valid"])
    
    await update.message.reply_text(
        "üçΩÔ∏è *–ß—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–≥–æ—Ç–æ–≤–∏—Ç—å?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(DISH_TYPE_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_DISH_TYPE

async def ask_validation_confirmation(update: Update, validation_result: dict):
    """–°–ø—Ä–∞—à–∏–≤–∞–µ—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø—Ä–∏ –ø—Ä–æ–±–ª–µ–º–∞—Ö —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π"""
    
    message_lines = ["ü§î *–Ø –Ω–∞—à–µ–ª –ø—Ä–æ–±–ª–µ–º—ã –≤ –≤–∞—à–µ–º —Å–ø–∏—Å–∫–µ:*"]
    
    if validation_result["valid"]:
        message_lines.append("\n‚úÖ *–ü—Ä–∏–Ω—è–ª:*")
        for product in validation_result["valid"]:
            message_lines.append(f"‚Ä¢ {product}")
    
    if validation_result["corrected"]:
        message_lines.append("\nüîÑ *–ò—Å–ø—Ä–∞–≤–∏–ª –æ–ø–µ—á–∞—Ç–∫–∏:*")
        for correction in validation_result["corrected"]:
            message_lines.append(f"‚Ä¢ {correction}")
    
    if validation_result["invalid"]:
        message_lines.append("\n‚ùå *–ù–µ –ø–æ–Ω—è–ª:*")
        for product in validation_result["invalid"]:
            message_lines.append(f"‚Ä¢ {product}")
    
    message_lines.append("\n*–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–µ—Ü–µ–ø—Ç –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø—Ä–æ–¥—É–∫—Ç–æ–≤?*")
    
    await update.message.reply_text(
        "\n".join(message_lines),
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(VALIDATION_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_VALIDATION_CONFIRMATION

@handle_telegram_errors
async def handle_validation_confirmation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –≤–∞–ª–∏–¥–∞—Ü–∏–∏"""
    user_choice = update.message.text
    validation_result = context.user_data.get('validation_result', {})
    
    if user_choice == "‚úÖ –î–∞, –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å" and validation_result.get("valid"):
        context.user_data['products'] = ', '.join(validation_result["valid"])
        
        await update.message.reply_text(
            "üçΩÔ∏è *–ß—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–∏–≥–æ—Ç–æ–≤–∏—Ç—å?*",
            parse_mode='Markdown',
            reply_markup=ReplyKeyboardMarkup(DISH_TYPE_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
        )
        
        return AWAITING_DISH_TYPE
    else:
        await update.message.reply_text(
            "üîÑ *–•–æ—Ä–æ—à–æ! –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –ø—Ä–æ–¥—É–∫—Ç–æ–≤.*\n\n"
            "*–°–æ–≤–µ—Ç:* –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–æ—Å—Ç—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è: –º–∞–π–æ–Ω–µ–∑, –∫–æ–ª–±–∞—Å–∞, —Å—ã—Ä, —Ö–ª–µ–± –∏ —Ç.–¥.",
            parse_mode='Markdown',
            reply_markup=ReplyKeyboardRemove()
        )
        
        return AWAITING_PRODUCTS

# ... –æ—Å—Ç–∞–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π (handle_dish_type, handle_time –∏ —Ç.–¥.) ...

def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
    try:
        if not all([BOT_TOKEN, YANDEX_API_KEY, FOLDER_ID]):
            logger.error("–ù–µ –≤—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã!")
            return
        
        application = Application.builder().token(BOT_TOKEN).build()
        
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler("start", start)],
            states={
                AWAITING_PRODUCTS: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_products)
                ],
                AWAITING_VALIDATION_CONFIRMATION: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_validation_confirmation)
                ],
                AWAITING_DISH_TYPE: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_dish_type)
                ],
                AWAITING_TIME: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_time)
                ],
                AWAITING_PREFERENCES: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_preferences)
                ],
                AWAITING_PORTIONS: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_portions)
                ],
                AWAITING_CALORIES: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_calories)
                ],
            },
            fallbacks=[CommandHandler("cancel", cancel)],
            allow_reentry=True
        )
        
        application.add_handler(conv_handler)
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_direct_message))
        
        logger.info("–ë–æ—Ç –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è...")
        application.run_polling(
            drop_pending_updates=True,
            allowed_updates=Update.ALL_TYPES
        )
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {e}")

if __name__ == "__main__":
    main()
