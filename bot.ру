#!/usr/bin/env python3
import os
import logging
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    filters, 
    ContextTypes, 
    ConversationHandler
)
import requests
import json

# Настройка логирования
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Получаем конфигурационные переменные из Railway
BOT_TOKEN = os.environ.get('BOT_TOKEN')
YANDEX_API_KEY = os.environ.get('YANDEX_API_KEY')
FOLDER_ID = os.environ.get('FOLDER_ID')

# URL для YandexGPT API
YANDEX_GPT_URL = "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"

# Состояния диалога
(
    AWAITING_PRODUCTS,
    AWAITING_DISH_TYPE, 
    AWAITING_TIME,
    AWAITING_PREFERENCES,
    AWAITING_PORTIONS,
    AWAITING_CALORIES
) = range(6)

# Клавиатуры для быстрого выбора
DISH_TYPE_KEYBOARD = [["🍲 Салат", "🍜 Суп"], ["🍛 Горячее", "🍰 Десерт"], ["🎲 Предложи вариант"]]
TIME_KEYBOARD = [["🔸 15 мин", "🔸 30 мин"], ["🔸 45 мин", "🔸 60 мин+"], ["⏰ Не важно"]]
PORTIONS_KEYBOARD = [["1-2", "3-4"], ["5-6", "7+"]]
CALORIES_KEYBOARD = [["✅ Да", "❌ Нет"]]

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /start"""
    welcome_text = """
🍳 *Привет! Я RecipeChefAI - твой умный помощник в готовке!*

Просто отправь мне список продуктов, которые у тебя есть, и я:
• Придумаю вкусный рецепт 🎯
• Учту твои пожелания ⭐  
• Подскажу по времени ⏱️
• Рассчитаю КБЖУ (по желанию) 📊

*Например:* `курица, рис, лук, морковь, помидоры`

*Готов готовить? Отправляй продукты!* 🚀
    """
    await update.message.reply_text(welcome_text, parse_mode='Markdown')
    
    # Очищаем предыдущие данные пользователя
    context.user_data.clear()
    
    return AWAITING_PRODUCTS

async def handle_products(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик получения списка продуктов"""
    user_message = update.message.text
    
    # Сохраняем продукты
    context.user_data['products'] = user_message
    
    # Спрашиваем тип блюда
    await update.message.reply_text(
        "🍽️ *Что хотите приготовить?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(DISH_TYPE_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_DISH_TYPE

async def handle_dish_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик выбора типа блюда"""
    dish_type = update.message.text
    context.user_data['dish_type'] = dish_type
    
    # Спрашиваем время
    await update.message.reply_text(
        "⏱️ *Сколько минут у вас есть на готовку?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(TIME_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_TIME

async def handle_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик выбора времени"""
    cooking_time = update.message.text
    context.user_data['cooking_time'] = cooking_time
    
    # Спрашиваем предпочтения
    await update.message.reply_text(
        "🌱 *Есть диетические ограничения или предпочтения?*\n\n"
        "*Например:* вегетарианское, острое, без молочного, диетическое\n"
        "*Или просто напишите:* нет",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardRemove()
    )
    
    return AWAITING_PREFERENCES

async def handle_preferences(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик предпочтений"""
    preferences = update.message.text
    context.user_data['preferences'] = preferences
    
    # Спрашиваем количество порций
    await update.message.reply_text(
        "👨‍👩‍👧‍👦 *На сколько человек готовим?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(PORTIONS_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_PORTIONS

async def handle_portions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик выбора порций"""
    portions = update.message.text
    context.user_data['portions'] = portions
    
    # Спрашиваем про расчет калорий
    await update.message.reply_text(
        "📊 *Рассчитать КБЖУ (калории, белки, жиры, углеводы) для рецепта?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(CALORIES_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return AWAITING_CALORIES

async def handle_calories(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик выбора расчета калорий и генерация рецепта"""
    calories_choice = update.message.text
    
    # Сохраняем выбор пользователя
    context.user_data['need_calories'] = calories_choice == "✅ Да"
    
    await update.message.reply_text(
        "🎯 *Отлично! Генерирую рецепт...*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardRemove()
    )
    
    try:
        # Показываем что бот печатает
        await update.message.chat.send_action(action="typing")
        
        # Создаем оптимизированный промт для YandexGPT
        prompt = create_optimized_prompt(context.user_data)
        
        # Отправляем запрос к YandexGPT
        recipe_text = await get_recipe_from_yagpt(prompt)
        
        # Форматируем и отправляем рецепт
        formatted_recipe = format_recipe_response(recipe_text, context.user_data.get('need_calories', False))
        await update.message.reply_text(formatted_recipe, parse_mode='HTML')
        
    except Exception as e:
        error_message = handle_error(e)
        await update.message.reply_text(error_message)
    
    # Очищаем данные после завершения диалога
    context.user_data.clear()
    return ConversationHandler.END

def create_optimized_prompt(user_data: dict) -> str:
    """Создает оптимизированный промт для YandexGPT"""
    
    products = user_data.get('products', '')
    dish_type = user_data.get('dish_type', '')
    cooking_time = user_data.get('cooking_time', '')
    preferences = user_data.get('preferences', '')
    portions = user_data.get('portions', '')
    need_calories = user_data.get('need_calories', False)
    
    calories_section = ""
    if need_calories:
        calories_section = "6. 📊 КБЖУ (калории, белки, жиры, углеводы на порцию)"
    
    prompt = f"""
Ты — опытный шеф-повар и диетолог. Создай кулинарный рецепт используя эти продукты: {products}

Дополнительные пожелания:
- Тип блюда: {dish_type}
- Время готовки: {cooking_time}
- Порции: {portions}
- Особенности: {preferences}

Структура рецепта:
1. 🍽️ Название блюда (емодзи)
2. 📋 Ингредиенты (точные количества для указанного числа порций)
3. 👨‍🍳 Приготовление (четкие пронумерованные шаги, максимум 5 шагов)
4. ⏱️ Общее время готовки
5. 💡 Полезный совет от шефа
{calories_section}

Требования:
- Рецепт ДОЛЖЕН быть реалистичным и выполнимым с указанными продуктами
- Учитывай ограничения по времени если они указаны
- Объем: 250-400 слов
- Язык: тот же что и запрос пользователя
- Только кулинарный рецепт, без лишних комментариев
"""
    return prompt

def format_recipe_response(recipe_text: str, need_calories: bool) -> str:
    """Форматирует ответ рецепта в красивый HTML"""
    
    lines = recipe_text.split('\n')
    formatted_lines = []
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        # Определяем тип строки и форматируем
        if any(marker in line for marker in ['🍽️', 'Название', '🥘']):
            formatted_lines.append(f"<b>{line}</b>\n")
        elif any(marker in line for marker in ['📋', 'Ингредиенты', '🥕']):
            formatted_lines.append(f"<b>{line}</b>")
        elif any(marker in line for marker in ['👨‍🍳', 'Приготовление', '🍳']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif any(marker in line for marker in ['⏱️', 'Время', '🕒']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif any(marker in line for marker in ['💡', 'Совет', '🌟']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif any(marker in line for marker in ['📊', 'КБЖУ', 'Калории']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif line.startswith(('•', '-', '1.', '2.', '3.', '4.', '5.')):
            formatted_lines.append(f"• {line.lstrip('•- 12345.')}")
        else:
            formatted_lines.append(line)
    
    formatted_text = '\n'.join(formatted_lines)
    
    if need_calories:
        formatted_text += "\n\n📊 <i>КБЖУ рассчитано приблизительно</i>"
    
    formatted_text += "\n\n#рецепт #вкусно #готовимдома"
    
    return formatted_text

async def get_recipe_from_yagpt(prompt: str) -> str:
    """Функция для взаимодействия с YandexGPT API"""
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Api-Key {YANDEX_API_KEY}",
        "x-folder-id": FOLDER_ID
    }
    
    data = {
        "modelUri": f"gpt://{FOLDER_ID}/yandexgpt-lite",
        "completionOptions": {
            "stream": False,
            "temperature": 0.7,
            "maxTokens": 2000
        },
        "messages": [
            {
                "role": "user",
                "text": prompt
            }
        ]
    }
    
    response = requests.post(YANDEX_GPT_URL, headers=headers, json=data, timeout=30)
    
    if response.status_code != 200:
        error_text = f"HTTP {response.status_code}: {response.text}"
        raise Exception(error_text)
    
    result = response.json()
    
    if ('result' not in result or 
        'alternatives' not in result['result'] or 
        not result['result']['alternatives']):
        raise Exception("Неверный формат ответа от YandexGPT")
    
    return result['result']['alternatives'][0]['message']['text']

def handle_error(error: Exception) -> str:
    """Обработка ошибок с понятными сообщениями"""
    error_message = str(error)
    logger.error(f"Ошибка: {error_message}")
    
    if "401" in error_message:
        return "🔐 Ошибка доступа к YandexGPT"
    elif "403" in error_message:
        return "🚫 Доступ запрещен"
    elif "429" in error_message:
        return "⏳ Превышен лимит запросов. Попробуйте позже"
    elif "500" in error_message:
        return "⚡ Ошибка сервера YandexGPT"
    else:
        return "❌ Произошла ошибка при генерации рецепта. Попробуйте еще раз."

async def handle_direct_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик сообщений вне диалога - предлагаем начать с /start"""
    await update.message.reply_text(
        "🍳 Чтобы получить рецепт, начните с команды /start\n\n"
        "Я помогу приготовить вкусное блюдо из ваших продуктов!",
        reply_markup=ReplyKeyboardRemove()
    )

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Отмена диалога"""
    context.user_data.clear()
    await update.message.reply_text(
        "Диалог отменен. Начните заново с /start",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

def main():
    """Основная функция запуска бота"""
    try:
        if not all([BOT_TOKEN, YANDEX_API_KEY, FOLDER_ID]):
            logger.error("Не все переменные окружения установлены!")
            return
        
        application = Application.builder().token(BOT_TOKEN).build()
        
        # Настраиваем ConversationHandler
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler("start", start)],
            states={
                AWAITING_PRODUCTS: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_products)
                ],
                AWAITING_DISH_TYPE: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_dish_type)
                ],
                AWAITING_TIME: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_time)
                ],
                AWAITING_PREFERENCES: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_preferences)
                ],
                AWAITING_PORTIONS: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_portions)
                ],
                AWAITING_CALORIES: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_calories)
                ],
            },
            fallbacks=[CommandHandler("cancel", cancel)],
            allow_reentry=True
        )
        
        application.add_handler(conv_handler)
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_direct_message))
        
        logger.info("Бот запускается...")
        application.run_polling(
            drop_pending_updates=True,
            allowed_updates=Update.ALL_TYPES
        )
        
    except Exception as e:
        logger.error(f"Ошибка при запуске бота: {e}")

if __name__ == "__main__":
    main()
