#!/usr/bin/env python3
import os
import logging
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application, 
    CommandHandler, 
    MessageHandler, 
    filters, 
    ContextTypes, 
    ConversationHandler
)
import requests
import json
from enum import Enum

# Настройка логирования
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Получаем конфигурационные переменные из Railway
BOT_TOKEN = os.environ['BOT_TOKEN']
YANDEX_API_KEY = os.environ['YANDEX_API_KEY'] 
FOLDER_ID = os.environ['FOLDER_ID']

# URL для YandexGPT API
YANDEX_GPT_URL = "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"

# Состояния диалога
class DialogState(Enum):
    AWAITING_PRODUCTS = 1
    AWAITING_DISH_TYPE = 2
    AWAITING_TIME = 3
    AWAITING_PREFERENCES = 4
    AWAITING_PORTIONS = 5

# Клавиатуры для быстрого выбора
DISH_TYPE_KEYBOARD = [["🍲 Салат", "🍜 Суп"], ["🍛 Горячее", "🍰 Десерт"], ["🎲 Предложи вариант"]]
TIME_KEYBOARD = [["🔸 15 мин", "🔸 30 мин"], ["🔸 45 мин", "🔸 60 мин+"], ["⏰ Не важно"]]
PORTIONS_KEYBOARD = [["1-2", "3-4"], ["5-6", "7+"]]

# Хранение данных пользователя во время диалога
user_data = {}

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик команды /start"""
    # Тестовая проверка переменных
    logger.info(f"BOT_TOKEN: {bool(BOT_TOKEN)}")
    logger.info(f"YANDEX_API_KEY: {bool(YANDEX_API_KEY)}") 
    logger.info(f"FOLDER_ID: {bool(FOLDER_ID)}")
    
    welcome_text = """
🍳 *Привет! Я RecipeChefAI...*

Просто отправь мне список продуктов, которые у тебя есть, и я:
• Придумаю вкусный рецепт 🎯
• Учту твои пожелания ⭐
• Подскажу по времени ⏱️

*Например:* `курица, рис, лук, морковь, помидоры`

*Готов готовить? Отправляй продукты!* 🚀
    """
    await update.message.reply_text(welcome_text, parse_mode='Markdown')
    return DialogState.AWAITING_PRODUCTS

async def handle_products(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик получения списка продуктов"""
    user_id = update.message.from_user.id
    user_message = update.message.text
    
    # Сохраняем продукты
    user_data[user_id] = {'products': user_message}
    
    # Спрашиваем тип блюда
    await update.message.reply_text(
        "🍽️ *Что хотите приготовить?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(DISH_TYPE_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return DialogState.AWAITING_DISH_TYPE

async def handle_dish_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик выбора типа блюда"""
    user_id = update.message.from_user.id
    dish_type = update.message.text
    
    user_data[user_id]['dish_type'] = dish_type
    
    # Спрашиваем время
    await update.message.reply_text(
        "⏱️ *Сколько минут у вас есть на готовку?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(TIME_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return DialogState.AWAITING_TIME

async def handle_time(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик выбора времени"""
    user_id = update.message.from_user.id
    cooking_time = update.message.text
    
    user_data[user_id]['cooking_time'] = cooking_time
    
    # Спрашиваем предпочтения
    await update.message.reply_text(
        "🌱 *Есть диетические ограничения или предпочтения?*\n\n"
        "*Например:* вегетарианское, острое, без молочного, диетическое\n"
        "*Или просто напишите:* нет",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardRemove()
    )
    
    return DialogState.AWAITING_PREFERENCES

async def handle_preferences(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик предпочтений"""
    user_id = update.message.from_user.id
    preferences = update.message.text
    
    user_data[user_id]['preferences'] = preferences
    
    # Спрашиваем количество порций
    await update.message.reply_text(
        "👨‍👩‍👧‍👦 *На сколько человек готовим?*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardMarkup(PORTIONS_KEYBOARD, one_time_keyboard=True, resize_keyboard=True)
    )
    
    return DialogState.AWAITING_PORTIONS

async def handle_portions(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик выбора порций и генерация рецепта"""
    user_id = update.message.from_user.id
    portions = update.message.text
    
    # Сохраняем порции и убираем клавиатуру
    user_data[user_id]['portions'] = portions
    
    await update.message.reply_text(
        "🎯 *Отлично! Генерирую рецепт...*",
        parse_mode='Markdown',
        reply_markup=ReplyKeyboardRemove()
    )
    
    try:
        # Показываем что бот печатает
        await update.message.chat.send_action(action="typing")
        
        # Создаем оптимизированный промт для YandexGPT
        user_info = user_data[user_id]
        prompt = create_optimized_prompt(user_info)
        
        # Отправляем запрос к YandexGPT
        recipe_text = await get_recipe_from_yagpt(prompt)
        
        # Форматируем и отправляем рецепт
        formatted_recipe = format_recipe_response(recipe_text)
        await update.message.reply_text(formatted_recipe, parse_mode='HTML')
        
        # Очищаем данные пользователя после успешной генерации
        if user_id in user_data:
            del user_data[user_id]
            
    except Exception as e:
        error_message = handle_error(e)
        await update.message.reply_text(error_message)
        
        # Очищаем данные при ошибке
        if user_id in user_data:
            del user_data[user_id]
    
    return ConversationHandler.END

def create_optimized_prompt(user_info: dict) -> str:
    """Создает оптимизированный промт для YandexGPT"""
    
    products = user_info.get('products', '')
    dish_type = user_info.get('dish_type', '')
    cooking_time = user_info.get('cooking_time', '')
    preferences = user_info.get('preferences', '')
    portions = user_info.get('portions', '')
    
    prompt = f"""
Ты — опытный шеф-повар. Создай кулинарный рецепт используя эти продукты: {products}

Дополнительные пожелания:
- Тип блюда: {dish_type}
- Время готовки: {cooking_time}
- Порции: {portions}
- Особенности: {preferences}

Структура рецепта:
1. 🍽️ Название блюда (емодзи)
2. 📋 Ингредиенты (точные количества для указанного числа порций)
3. 👨‍🍳 Приготовление (четкие пронумерованные шаги, максимум 5 шагов)
4. ⏱️ Общее время готовки
5. 💡 Полезный совет от шефа

Требования:
- Рецепт ДОЛЖЕН быть реалистичным и выполнимым с указанными продуктами
- Учитывай ограничения по времени если они указаны
- Объем: 250-400 слов
- Язык: тот же что и запрос пользователя
- Только кулинарный рецепт, без лишних комментариев
"""
    return prompt

def format_recipe_response(recipe_text: str) -> str:
    """Форматирует ответ рецепта в красивый HTML"""
    
    # Базовая обработка текста для улучшения читаемости
    lines = recipe_text.split('\n')
    formatted_lines = []
    
    for line in lines:
        line = line.strip()
        if not line:
            continue
            
        # Определяем тип строки и форматируем
        if any(marker in line for marker in ['🍽️', 'Название', '🥘']):
            formatted_lines.append(f"<b>{line}</b>\n")
        elif any(marker in line for marker in ['📋', 'Ингредиенты', '🥕']):
            formatted_lines.append(f"<b>{line}</b>")
        elif any(marker in line for marker in ['👨‍🍳', 'Приготовление', '🍳']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif any(marker in line for marker in ['⏱️', 'Время', '🕒']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif any(marker in line for marker in ['💡', 'Совет', '🌟']):
            formatted_lines.append(f"\n<b>{line}</b>")
        elif line.startswith(('•', '-', '1.', '2.', '3.', '4.', '5.')):
            formatted_lines.append(f"• {line.lstrip('•- 12345.')}")
        else:
            formatted_lines.append(line)
    
    # Добавляем хештеги в конец
    formatted_text = '\n'.join(formatted_lines)
    formatted_text += "\n\n#рецепт #вкусно #готовимдома"
    
    return formatted_text

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Отмена диалога"""
    user_id = update.message.from_user.id
    if user_id in user_data:
        del user_data[user_id]
    
    await update.message.reply_text(
        "Диалог отменен. Начните заново с /start",
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Обработчик случайных сообщений вне диалога"""
    await update.message.reply_text(
        "Чтобы получить рецепт, начните с команды /start 🍳"
    )

async def get_recipe_from_yagpt(prompt: str) -> str:
    """Функция для взаимодействия с YandexGPT API"""
    
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Api-Key {YANDEX_API_KEY}",
        "x-folder-id": FOLDER_ID
    }
    
    data = {
        "modelUri": f"gpt://{FOLDER_ID}/yandexgpt-lite",
        "completionOptions": {
            "stream": False,
            "temperature": 0.7,
            "maxTokens": 2000
        },
        "messages": [
            {
                "role": "user",
                "text": prompt
            }
        ]
    }
    
    response = requests.post(YANDEX_GPT_URL, headers=headers, json=data, timeout=30)
    
    if response.status_code != 200:
        error_text = f"HTTP {response.status_code}: {response.text}"
        raise Exception(error_text)
    
    result = response.json()
    
    if ('result' not in result or 
        'alternatives' not in result['result'] or 
        not result['result']['alternatives']):
        raise Exception("Неверный формат ответа от YandexGPT")
    
    return result['result']['alternatives'][0]['message']['text']

def handle_error(error: Exception) -> str:
    """Обработка ошибок с понятными сообщениями"""
    error_message = str(error)
    logger.error(f"Ошибка: {error_message}")
    
    if "401" in error_message:
        return "🔐 Ошибка доступа к YandexGPT"
    elif "403" in error_message:
        return "🚫 Доступ запрещен"
    elif "429" in error_message:
        return "⏳ Превышен лимит запросов. Попробуйте позже"
    elif "500" in error_message:
        return "⚡ Ошибка сервера YandexGPT"
    else:
        return "❌ Произошла ошибка при генерации рецепта. Попробуйте еще раз."

def main():
    """Основная функция запуска бота"""
    try:
        # Проверяем переменные при запуске
        if not all([BOT_TOKEN, YANDEX_API_KEY, FOLDER_ID]):
            logger.error("Не все переменные окружения установлены!")
            return
        
        # Создаем приложение
        application = Application.builder().token(BOT_TOKEN).build()
        
        # Настраиваем ConversationHandler для многошагового диалога
        conv_handler = ConversationHandler(
            entry_points=[CommandHandler("start", start)],
            states={
                DialogState.AWAITING_PRODUCTS: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_products)
                ],
                DialogState.AWAITING_DISH_TYPE: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_dish_type)
                ],
                DialogState.AWAITING_TIME: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_time)
                ],
                DialogState.AWAITING_PREFERENCES: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_preferences)
                ],
                DialogState.AWAITING_PORTIONS: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, handle_portions)
                ],
            },
            fallbacks=[CommandHandler("cancel", cancel)]
        )
        
        # Добавляем обработчики
        application.add_handler(conv_handler)
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
        
        # Запускаем бота
        logger.info("Бот запускается...")
        application.run_polling(
            drop_pending_updates=True,
            allowed_updates=Update.ALL_TYPES
        )
        
    except Exception as e:
        logger.error(f"Ошибка при запуске бота: {e}")

if __name__ == "__main__":
    main()
