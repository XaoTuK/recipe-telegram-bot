import os
import logging
import requests
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes

# Настройка логирования
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class YandexGPTProxy:
    def __init__(self):
        self.api_key = os.getenv('YANDEX_API_KEY')
        self.folder_id = os.getenv('YANDEX_FOLDER_ID')
        self.proxy_url = os.getenv('PROXY_URL')
        
    def get_proxies(self):
        if self.proxy_url:
            return {
                'http': self.proxy_url,
                'https': self.proxy_url
            }
        return None
    
    def make_request(self, messages):
        url = "https://llm.api.cloud.yandex.net/foundationModels/v1/completion"
        
        headers = {
            "Authorization": f"Api-Key {self.api_key}",
            "Content-Type": "application/json"
        }
        
        data = {
            "modelUri": f"gpt://{self.folder_id}/yandexgpt-lite",
            "completionOptions": {
                "stream": False,
                "temperature": 0.7,
                "maxTokens": 2000
            },
            "messages": messages
        }
        
        try:
            response = requests.post(
                url,
                json=data,
                headers=headers,
                proxies=self.get_proxies(),
                timeout=(10, 30)  # 10 сек на подключение, 30 сек на чтение
            )
            
            if response.status_code == 200:
                result = response.json()
                return result['result']['alternatives'][0]['message']['text']
            else:
                logger.error(f"Yandex API error: {response.status_code} - {response.text}")
                return None
                
        except requests.exceptions.Timeout:
            logger.error("Request timeout")
            return None
        except requests.exceptions.ConnectionError:
            logger.error("Connection error")
            return None
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            return None

# Инициализация Яндекс GPT
yandex_gpt = YandexGPTProxy()

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Привет! Я бот-шеф. Напиши мне, что хочешь приготовить, и я помогу с рецептом!"
    )

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_message = update.message.text
    
    # Показываем индикатор набора
    await context.bot.send_chat_action(chat_id=update.effective_chat.id, action="typing")
    
    messages = [
        {
            "role": "system",
            "text": "Ты профессиональный шеф-повар. Давай подробные рецепты с ингредиентами и пошаговыми инструкциями. Будь креативным и полезным."
        },
        {
            "role": "user",
            "text": user_message
        }
    ]
    
    response_text = yandex_gpt.make_request(messages)
    
    if response_text:
        await update.message.reply_text(response_text)
    else:
        await update.message.reply_text(
            "Извините, возникла проблема с подключением к сервису. Попробуйте позже."
        )

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Exception while handling an update: {context.error}")

def main():
    # Создаем приложение
    application = Application.builder().token(os.getenv('TELEGRAM_TOKEN')).build()
    
    # Добавляем обработчики
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    
    # Обработчик ошибок
    application.add_error_handler(error_handler)
    
    # Запускаем бота
    application.run_polling()

if __name__ == '__main__':
    main()
